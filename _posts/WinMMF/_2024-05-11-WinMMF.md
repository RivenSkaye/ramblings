---
layout: post
author: Riven Skaye
tags: [ipc, windows, shared-mem, winmmf, rust, tech]
series: WinMMF
category: winmmf
title: WinMMF - Sharing the braincell
---
# Sharing memory on Windows

## And why you should (not) forget about it

So the initial implementation was _almost_ quickly written. I reasonably quickly decided that, since the goal is to share many bytes of data, I wasn't going to use the `W`-APIs (16-bit Unicode) as all we need here is a unique (user-provided) name for the mapping to be created. There are common conventions, most of which include using your application (or lib/namespace/crate/etc) name as a prefix to ensure uniqueness. The OS API wants a [`PCSTR`](https://docs.rs/windows-core/0.57.0/windows_core/struct.PCSTR.html) which turns out to just be a pointer to a string, which it uses to map clients requesting the same named memory into the same address space. Oh and if that memory needs to be accessible to processes that are not your children, you should prefix it with `GLOBAL\` and be sure to have the right permissions. Which for globally accessible shared memory means running as a service or an admin. This is where the funny stuff started happening. Turns out the OS internals hold no copy of the data or anything, they just store that pointer into your program. This is problematic for a few reasons, and we'll get there in a little bit to go over the problems this causes. First up, however, is how I found this out. And _why_.

The minimal test application was about as unsafe as `use after free` meets `thread panicked while holding a lock` and `passing null pointers and casting them` combined. You see, I thought creating the `PCSTR` and keeping that reference would be fine. There was some abiguity with regards to what the `PCSTR` was built up of (this ambiguity has since been fixed) that made it seem like I was getting a proper struct back. Alas, it's a wrapper around a `(*const u8)`. So that was really just taking a pointer to the first u8 and rolling with it. I only found out because trying to dump the names of the mappings I opened got me garbage data after a few tries. So then I started playing around, and lo and behold it was properly functional when I ignored the `PCSTR` and instead just kept the [`fixedstr::zstr`](https://docs.rs/fixedstr/latest/fixedstr/struct.zstr.html) around. A small, simple, `[u8;N]`-based String-like type that ensures `NUL` terminators are present. Literally perfect for what the Windows API wants, and it even provides a _safe_ method to acquire that pointer! But this does bring us to what's so potentially dangerous about this API. If the process that first opened the file exits, no other processes can open that mapping unless they manage to get a pointer to the exact same (freed and mangled) address. Leaking the pointer makes no difference here; the OS sees the process exit and frees remaining resources, decreases the reference count to the mapped memory, and allows whoever `malloc`s something that fits to take the address. Up to a certain point this makes sense though, as it ensures that no new processes can spawn without permissions that keep it alive once the initiator exits. Except processes that mapped that memory while the initiator lived still keep it open...

Long story short, the minimal implementation did work. Sure, there was no locking or checking anything yet, but I managed to read from a different handle than what I wrote from. On a global mapping!
